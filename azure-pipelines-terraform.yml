trigger:
  branches:
    include:
    - main
  paths:
    exclude:
    - README.md
    - docs/*

variables:
  # Docker Configuration
  dockerRegistryServiceConnection: 'docker-hub-connection'
  imageRepository: 'moheie/solar-system'
  containerRegistry: 'docker.io'
  dockerfilePath: './Dockerfile'
  tag: '$(Build.BuildId)'
  
  # AWS Configuration
  awsServiceConnection: 'aws-service-connection'
  awsRegion: 'us-west-2'
  clusterName: 'solar-system-cluster'
  namespace: 'solar-system'
  
  # Terraform Configuration
  terraformVersion: '1.5.7'
  terraformWorkingDirectory: './terraform'

stages:
- stage: Build
  displayName: 'Build and Push Docker Image'
  jobs:
  - job: Build
    displayName: 'Build Docker Image'
    pool:
      name: 'Default'  # Self-hosted agent pool
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: 'build'
        Dockerfile: '$(dockerfilePath)'
        tags: |
          $(tag)
          latest
    
    - task: Docker@2
      displayName: 'Push Docker Image'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: 'push'
        tags: |
          $(tag)
          latest

- stage: Infrastructure
  displayName: 'Deploy Infrastructure with Terraform'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: Terraform
    displayName: 'Terraform Infrastructure Deployment'
    pool:
      name: 'Default'  # Self-hosted agent pool
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: '$(terraformVersion)'
    
    - task: AWSShellScript@1
      displayName: 'Configure AWS Credentials'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          Write-Host "AWS credentials configured successfully"
          aws sts get-caller-identity
    
    - task: PowerShell@2
      displayName: 'Prepare Terraform Variables'
      inputs:
        targetType: 'inline'
        script: |
          # Create terraform.tfvars from template
          $terraformDir = "$(System.DefaultWorkingDirectory)/terraform"
          $tfvarsExample = "$terraformDir/terraform.tfvars.example"
          $tfvars = "$terraformDir/terraform.tfvars"
          
          Write-Host "Creating terraform.tfvars from example..."
          Copy-Item $tfvarsExample $tfvars -Force
          
          # Update variables with pipeline values
          $content = Get-Content $tfvars
          $content = $content -replace 'aws_region = "us-west-2"', 'aws_region = "$(awsRegion)"'
          $content = $content -replace 'cluster_name = "solar-system-cluster"', 'cluster_name = "$(clusterName)"'
          $content | Set-Content $tfvars
          
          Write-Host "terraform.tfvars prepared successfully"
    
    - task: AWSShellScript@1
      displayName: 'Terraform Init'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          cd $(terraformWorkingDirectory)
          Write-Host "Initializing Terraform..."
          terraform init
          Write-Host "Terraform initialized successfully"
    
    - task: AWSShellScript@1
      displayName: 'Terraform Validate'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          cd $(terraformWorkingDirectory)
          Write-Host "Validating Terraform configuration..."
          terraform validate
          Write-Host "Terraform configuration is valid"
    
    - task: AWSShellScript@1
      displayName: 'Terraform Plan'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          cd $(terraformWorkingDirectory)
          Write-Host "Planning Terraform deployment..."
          terraform plan -var-file="terraform.tfvars" -out=tfplan -detailed-exitcode
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -eq 0) {
            Write-Host "No changes detected in infrastructure"
          } elseif ($exitCode -eq 2) {
            Write-Host "Changes detected, deployment will proceed"
          } else {
            Write-Error "Terraform plan failed with exit code: $exitCode"
            exit $exitCode
          }
    
    - task: AWSShellScript@1
      displayName: 'Terraform Apply'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          cd $(terraformWorkingDirectory)
          Write-Host "Applying Terraform deployment..."
          terraform apply -auto-approve tfplan
          Write-Host "Infrastructure deployed successfully"
    
    - task: AWSShellScript@1
      displayName: 'Configure kubectl'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          Write-Host "Configuring kubectl..."
          aws eks update-kubeconfig --region $(awsRegion) --name $(clusterName)
          
          Write-Host "Verifying cluster connection..."
          kubectl cluster-info
          
          Write-Host "kubectl configured successfully"
    
    - task: AWSShellScript@1
      displayName: 'Verify Deployment'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          Write-Host "Waiting for application pods to be ready..."
          kubectl wait --for=condition=ready pod -l app=solar-system -n $(namespace) --timeout=300s
          
          Write-Host "Checking deployment status..."
          kubectl get pods -n $(namespace)
          kubectl get svc -n $(namespace)
          
          Write-Host "Getting LoadBalancer URL..."
          $attempts = 0
          $maxAttempts = 30
          
          do {
            $lbUrl = kubectl get svc solar-system-service -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>$null
            if ($lbUrl) {
              Write-Host "ðŸŒŸ Application is accessible at: http://$lbUrl"
              break
            }
            $attempts++
            Write-Host "Waiting for LoadBalancer... ($attempts/$maxAttempts)"
            Start-Sleep 10
          } while ($attempts -lt $maxAttempts)
          
          if (-not $lbUrl) {
            Write-Warning "LoadBalancer URL not yet available. Check later with: kubectl get svc -n $(namespace)"
          }
    
    - task: AWSShellScript@1
      displayName: 'Show Terraform Outputs'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          cd $(terraformWorkingDirectory)
          Write-Host "Terraform Outputs:"
          terraform output
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Terraform State'
      inputs:
        targetPath: '$(terraformWorkingDirectory)/terraform.tfstate'
        artifact: 'terraform-state'
        publishLocation: 'pipeline'
      condition: always()

- stage: ApplicationUpdate
  displayName: 'Update Application Image'
  dependsOn: 
  - Build
  - Infrastructure
  condition: succeeded()
  jobs:
  - job: UpdateApp
    displayName: 'Update Application with New Image'
    pool:
      name: 'Default'  # Self-hosted agent pool
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: AWSShellScript@1
      displayName: 'Update Application Image'
      inputs:
        awsCredentials: '$(awsServiceConnection)'
        regionName: '$(awsRegion)'
        scriptType: 'inline'
        inlineScript: |
          Write-Host "Configuring kubectl..."
          aws eks update-kubeconfig --region $(awsRegion) --name $(clusterName)
          
          Write-Host "Updating application image to: $(imageRepository):$(tag)"
          kubectl set image deployment/solar-system solar-system=$(imageRepository):$(tag) -n $(namespace)
          
          Write-Host "Waiting for rollout to complete..."
          kubectl rollout status deployment/solar-system -n $(namespace) --timeout=300s
          
          Write-Host "Verifying updated deployment..."
          kubectl get pods -n $(namespace)
          kubectl describe deployment solar-system -n $(namespace)
          
          Write-Host "Application updated successfully with new image: $(imageRepository):$(tag)"
